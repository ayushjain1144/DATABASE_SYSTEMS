CREATE FUNCTION NO_OF_EMP()
RETURNS INTEGER
AS
BEGIN
DECLARE @COUNT INTEGER
SELECT @COUNT = COUNT(*) FROM EMPLOYEES;
RETURN @COUNT;
END

SELECT DBO.NO_OF_EMP() AS 'NUMBER';

CREATE FUNCTION MAX_OF_TWO
(@X INTEGER, @Y INTEGER)
RETURNS INTEGER 
AS
BEGIN
DECLARE @Z NUMERIC(10);
	IF @X > @Y
		SET @Z = @X;
	ELSE
		SET @Z = @Y;
	
	RETURN @Z
END

DROP FUNCTION DBO.MAX_OF_TWO

SELECT DBO.MAX_OF_TWO(34, 45) AS 'MAX';

CREATE FUNCTION FACTORIAL
(@X INTEGER)
RETURNS INTEGER
AS

BEGIN

DECLARE @Z INTEGER;

IF @X = 1
	SET @Z = 1;

ELSE

	SET @Z = (@X) * DBO.FACTORIAL(@X - 1);

RETURN @Z;

END

SELECT DBO.FACTORIAL(5) AS 'FACT';


CREATE FUNCTION FACTORIAL_ITER
(@X INTEGER)
RETURNS INTEGER
AS
BEGIN
	DECLARE @Z INTEGER;

	SET @Z = 1;
	
	WHILE @X != 0
	BEGIN
		SET @Z = @Z * @X;
		SET @X = @X - 1;
	END

	RETURN @Z;


END

DROP FUNCTION DBO.FACTORIAL_ITER
SELECT DBO.FACTORIAL_ITER(5) AS 'FACT';

CREATE FUNCTION DETAILS
(@ID INTEGER)
RETURNS TABLE 
AS

RETURN SELECT P.PROJECTID, P.DEPTCODE, P.DESCRIPTION FROM 
PROJECTS P JOIN WORKSON W
ON P.PROJECTID = W.projectid JOIN
EMPLOYEES E ON
W.employeeid = E.employeeid
WHERE E.employeeid = @ID;

SELECT * FROM DBO.DETAILS(2);

CREATE FUNCTION DETAILS_2
(@ID INTEGER)
RETURNS @PROJECT1 TABLE
(PROJECTID CHAR(8) NOT NULL,
DEPTCODE CHAR(5),
DESCRIPTION VARCHAR(200)
)

AS

BEGIN

	INSERT INTO @PROJECT1
	SELECT PROJECTID, DEPTCODE, DESCRIPTION
	FROM PROJECTS
	WHERE PROJECTID IN (SELECT PROJECTID FROM WORKSON WHERE EMPLOYEEID = @ID);

 RETURN
 END

 SELECT * FROM DBO.DETAILS_2(2);
 

CREATE FUNCTION FIBBONACCI
(@X INTEGER)
RETURNS INTEGER
AS

BEGIN
	
	DECLARE @Z INTEGER;
	IF @X = 1 OR @X = 0
		SET @Z = @X;

	ELSE
	BEGIN
		SET @Z = DBO.FIBBONACCI(@X - 1) + DBO.FIBBONACCI(@X - 2);
	END

	RETURN @Z;
END
DROP FUNCTION FIBBONACCI;
SELECT DBO.FIBBONACCI(4) AS 'NUM';


CREATE FUNCTION FIB_ITER
(@X INTEGER)
RETURNS @FIB_TABLE TABLE
(N INTEGER)
AS

BEGIN
	DECLARE @Z INTEGER;
	DECLARE @COUNTER INTEGER;
	SET @COUNTER = 1;

	WHILE @COUNTER <= @X
	BEGIN
	SET @Z = DBO.FIBBONACCI(@COUNTER);
	INSERT INTO @FIB_TABLE
	VALUES(@Z);

	SET @COUNTER = @COUNTER + 1;
	END

RETURN
END

SELECT * FROM FIB_ITER(11);

--PROCEDURE

CREATE PROCEDURE FINDMIN(@X INTEGER, @Y INTEGER, @Z INTEGER OUTPUT)
AS BEGIN
	IF(@X < @Y)
	BEGIN
		SET @Z = @X
	END

	ELSE
	BEGIN
		SET @Z = @Y;
	END

END

DECLARE @X INTEGER, @A INTEGER, @B INTEGER;
BEGIN
	SET @A = 10;
	SET @B = 20;
	EXEC FINDMIN @A, @B, @X OUTPUT;
	PRINT 'THE MINIMUM IS ' + CAST(@X AS VARCHAR);
END

PRINT 'THE MINIMUM IS ' + CAST(@X AS VARCHAR);

CREATE PROCEDURE SQUARE_NUM(@IN INTEGER, @OUT INTEGER OUTPUT)
AS 
BEGIN
	SET @OUT = @IN * @IN;
	--PRINT 'SQUARE OF ' + CAST(@IN AS VARCHAR) + ' IS ' +
		--CAST(@OUT AS VARCHAR);
		 

END

DROP PROCEDURE SQUARE_NUM

DECLARE @X INTEGER, @Y INTEGER;
BEGIN
	SET @X = 10;
	EXEC SQUARE_NUM @X, @Y OUTPUT;
	PRINT @Y;
END

--cursor

DECLARE INFO_CURSOR CURSOR FOR
SELECT INGREDIENTID, NAME, UNIT FROM INGREDIENTS;
DECLARE @ID VARCHAR(20), @NAME VARCHAR(20), @UNIT VARCHAR(20);
OPEN INFO_CURSOR;
FETCH NEXT FROM INFO_CURSOR INTO @ID, @NAME, @UNIT;

WHILE @@FETCH_STATUS = 0
BEGIN
	
	IF @UNIT IS NOT NULL
	BEGIN
		
		PRINT (@ID + ' ' + @NAME + ' ' + @UNIT);
	END
	FETCH NEXT FROM INFO_CURSOR INTO @ID, @NAME, @UNIT; 

END


CLOSE INFO_CURSOR;
DEALLOCATE INFO_CURSOR;









